/**
 * {{SCRIPT_NAME}}
 *
 * What this Policy/Guard is for
 * Evaluate rules and decide whether the flow is allowed to proceed.
 * Policies should not cause side effects; they only produce decisions.
 *
 * How to use
 * - Provide decision inputs via params.variables (recommended).
 * - Publish:
 *   - policy_decision  "allow" | "deny"
 *   - policy_reason    short explanation
 *   - policy_warnings_json optional stringified list
 *
 * Recommended pattern
 * - Keep rules deterministic and explainable.
 * - Let downstream steps decide what to do on deny (stop, notify, etc.).
 *
 * ID: {{ITEM_ID}}
 * Type: policy
 * Domain: {{ITEM_DOMAIN}}
 */

const SET_SCRIPT_NAME = "Script name";
const SET_DEBUG = "Debug mode";

module.exports = {
  entry: async (params, settings) => {
    try {
      const result = await run(params, settings || {});
      const d = params?.variables?.policy_decision || "allow";
      new Notice(result?.notice ?? (d === "deny" ? `⛔ Policy denied: {{ITEM_ID}}` : `✅ Policy allowed: {{ITEM_ID}}`));
      return result;
    } catch (err) {
      if (err?.name === "MacroAbortError") return { ok: false, aborted: true };
      console.error(`[{{ITEM_ID}}] FAILED`, err);
      new Notice(`❌ Policy failed: ${err?.message ?? String(err)}`);
      throw err;
    }
  },

  settings: {
    name: "{{SCRIPT_NAME}}",
    author: "{{SCRIPT_AUTHOR}}",
    options: {
      [SET_SCRIPT_NAME]: { type: "text", defaultValue: "{{ITEM_SLUG}}" },
      [SET_DEBUG]: { type: "toggle", defaultValue: false },
    },
  },
};

async function run(params, settings) {
  const { quickAddApi, variables } = params;

  const scriptName = String(settings?.[SET_SCRIPT_NAME] || "{{ITEM_SLUG}}");
  const debug = !!settings?.[SET_DEBUG];
  const log = (...a) => debug && console.log(`[${scriptName}]`, ...a);

  if (!quickAddApi) throw new Error("quickAddApi not available. Run this via a QuickAdd Macro.");

  const now = window.moment();
  const ctx = { date: now.format("YYYY-MM-DD"), datetime: now.toISOString() };

  // helpers
  const hasOwn = (k) => Object.prototype.hasOwnProperty.call(variables || {}, k);
  const shouldPrompt = (k) => !hasOwn(k) || variables[k] === undefined || variables[k] === null;

  async function requireVarOrPrompt(key, label, defaultValue = "") {
    if (!shouldPrompt(key)) return variables[key];
    const val = await quickAddApi.inputPrompt(label, defaultValue);
    if (val === null) throw macroAbort();
    variables[key] = val;
    return val;
  }

  function publish(outputs) {
    for (const [k, v] of Object.entries(outputs || {})) variables[k] = (v === undefined || v === null) ? "" : v;
  }

  function macroAbort() {
    const e = new Error("User cancelled");
    e.name = "MacroAbortError";
    return e;
  }

  // -----------------------------
  // TODO: implement your policy logic
  // -----------------------------
  // Example pattern:
  // const status = String(await requireVarOrPrompt("subscription_status", "Subscription status:"));
  // const allowed = ["installed", "usable"].includes(status);
  // const decision = allowed ? "allow" : "deny";
  // const reason = allowed ? "Subscription is installed & usable." : "Not installed/usable yet.";

  const decision = String(variables.policy_decision || "allow"); // default allow
  const reason = String(variables.policy_reason || "No explicit rule configured (default allow).");
  const warnings = []; // add strings here if useful

  log("POLICY", { decision, reason, warnings });

  publish({
    policy_id: "{{ITEM_ID}}",
    policy_domain: "{{ITEM_DOMAIN}}",
    policy_decision: decision === "deny" ? "deny" : "allow",
    policy_reason: reason,
    policy_warnings_json: warnings.length ? JSON.stringify(warnings) : "",
    last_item_id: "{{ITEM_ID}}",
    last_item_ran_at: ctx.datetime,
  });

  return {
    ok: true,
    ctx,
    decision,
    notice: decision === "deny" ? `⛔ Policy denied ({{ITEM_ID}})` : `✅ Policy allowed ({{ITEM_ID}})`,
  };
}
